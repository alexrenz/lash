{"name":"Lash","tagline":"Large-Scale Sequence Mining with Hierarchies","body":"LASH\r\n===================\r\n----------\r\n#Introduction\r\n------------\r\nLASH is a scalable, distributed algorithm for mining sequential patterns in the presence of hierarchies. LASH takes as input a collection of sequences, each composed of items from some application-specific vocabulary. In contrast to traditional approaches to sequence mining, the items in the vocabulary are arranged in a hierarchy: both input sequences and sequential patterns may consist of items from different levels of the hierarchy. For example, the individual words in a text document can be arranged in a *syntactic hierarchy*: words (e.g., \"lives\") generalize to their lemma (\"live\"), which in turn generalize to their respective part-of-speech tag (\"verb\"). Products in sequences of customer transactions also form a natural *product hierarchy*, e.g. \"Canon EOS 70D\" may generalize to \"digital camera\", which generalizes to \"photography\", which in turn generalizes to \"electronics\". Entities such as persons can be arranged in \"semantic hierarchies\"; e.g., \"Barack Obama\" may generalize to \"politician\", \"person\", \"entity\". \r\nThis generalization allows us to find sequences that would otherwise be hidden. For example, in the context of text\r\nmining, such patterns include generalized *n*-grams (the ADJ house) or typed relational patterns (PERSON lives in CITY). In both cases, the patterns do not actually occur in the input data, but are useful for language modeling or information extraction tasks. Hierarchies can also be exploited when mining market-basket data or product sequences. For example, users may first buy some camera, then some photography book, and finally some flash. A detailed description about LASH can be found in the [SIGMOD 2015 paper].\r\n\r\n[SIGMOD 2015 paper]: http://dws.informatik.uni-mannheim.de/fileadmin/shared/pi1/kbeedkar/publications/beedkar15lash.pdf\r\n\r\n----------\r\n\r\n\r\n#LASH Overview\r\n------------------\r\nGiven a collection of input sequences of items and an item hierarchy, LASH mines all generalized sub-sequences (along with their frequencies) that:\r\n- Occur in at least σ ≥ 2 sequences (support threshold)\r\n- Have length at most λ ≥ 2 (length threshold)\r\n- Have gap at most γ ≥ 0 between consecutive items (gap threshold)\r\n\r\n#Building LASH\r\n-----------------\r\n1. Prerequisites for building LASH\r\n\t- Java JDK 1.6 or higher\r\n\t- Maven 3.0 or higher\r\n\t- Hadoop (for distributed processing)\r\n2. Set the environment variables\r\n```sh\r\n$ export JAVA_HOME=/location/of/java/\r\n$ # for running on a hadoop cluster\r\n$ export HADOOP_HOME=/location/of/Hadoop/\r\n```\r\n3. Check out the LASH source code to some directory, we will call it here has LASH_HOME\r\n4. Compiling\r\n```sh\r\n$ cd LASH_HOME\r\n$ mvn clean install\r\n```\r\n\r\n#Running LASH\r\n-----------\r\n##Input Format\r\n####Input sequences\r\nThe input sequnce file(s) should have the following format:\r\n```\r\nseqId item_1 item_2 item_3 . . . item_n\r\n```\r\ni.e., the first token of each line (whitespace delimited) becomes the sequence id, and all additional text of the line is interpreted as a sequence of items. \r\n\r\n####Hierarchies\r\nItem hierarchies should be specified in a *single* file using the following format:\r\n```\r\nitem <tab> parent\r\n```\r\ni.e., each line (tab delimited) contains an item and its generalization (parent item). Note that each item in the hierarchy should have only one parent, i.e., the hierarchy should form a forest.\r\n\r\n##Sequential Mode\r\nThe sequential version of the algorithm runs locally on a single machine. \r\n```sh\r\n$ LASH_HOME/bin/lash -i path/to/input/ -H path/to/hierarchy/ -o path/to/output -s σ -g γ -l λ -m s\r\n```\r\n\r\n##Distributed Mode\r\nTo run LASH on a Hadoop cluster, issue the (d)istributed mode.\r\n```sh\r\n$ LASH_HOME/bin/lash -i path/to/input/ -H path/to/hierarchy -o path/to/output/ -s σ -g γ -l λ -m d\r\n```\t\r\n>  Note: \r\n> `path/to/input/` should point to the **directory** containg input sequence file(s).\r\n> `path/to/hierarchy` should point to the **hierarchy file** (the hierarchy file should not be in the same directory as input sequence files).\r\n> `path/to/output/` should point to the **directory** where output will be written.\r\n\r\n\r\n##Output Format\r\n```\r\nsequence <tab> frequency\r\n```\r\n\r\n##Example\r\nAssume that we have the following product sequences in the input file `SAMPLE_INPUT/input.txt`\r\n```\r\ns1 Cannon_EOS_70D The_Digital_Photography SanDisk_Extreme_32GB Dolica_GX600B200\r\ns2 Nikon_D5300 On_Photography Ravelli_APGL5\r\ns3 Canon_SX410 The_Art_of_Photography Kingston_8_GB_microSDHC\r\n```\r\nand a product hierarchy in the file `hierarchy.txt`\r\n```\r\nCannon_EOS_70D          DSLR_Camera\r\nNikon_D5300             DSLR_Camera\r\nCanon_SX410             PointShoot_Camera\r\nDSLR_Camera             Camera\r\nPointShoot_Camera       Camera\r\nDolica_GX600B200        Tripod\r\nRavelli_APGL5           Tripod\r\nThe_Digital_Photography Photography_Book\r\nOn_Photography          Photography_Book\r\nThe_Art_of_Photography  Photography_Book\r\nSanDisk_Extreme_32GB    Flash\r\nKingston_8_GB_microSDHC Flash\r\n```\r\nRun the following command to find all **generalized sequences** with minimum support=2, maximum length=3 and maximum gap=1.\r\n```sh\r\nbin/lash -i SAMPLE_INPUT/ -H hierarchy.txt -o SAMPLE_OUPUT/ -s 2 -g 1 -l 3 -m s\r\n```\r\nSample output:\r\n```\r\nCamera Photography_Book \t3\r\nCamera Photography_Book Tripod \t2\r\nCamera Photography_Book Flash \t2\r\nCamera Flash \t2\r\nDSLR_Camera Photography_Book \t2\r\nDSLR_Camera Photography_Book Tripod \t2\r\nPhotography_Book Tripod \t2\r\nPhotography_Book Flash \t2\r\n```\r\n##Command line options\r\n```\r\n -g,--gap <arg>           maximum gap.\r\n -H,--hierarchy <arg>     hierarchy path.\r\n -h,--help                show help.\r\n -i,--input <arg>         input path.\r\n -k,--keepFiles <arg>     translated input path.\r\n -l,--length <arg>        maximum length.\r\n -m,--mode <arg>          execution mode: (s)equential or (d)istributed.\r\n -n,--numReducers <arg>   number of reducers.\r\n -o,--output <arg>        output path.\r\n -r,--resume <arg>        translated input path.\r\n -s,--support <arg>       minimum support.\r\n ```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}